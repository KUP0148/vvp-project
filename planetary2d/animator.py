"""
``planetary2d.animator``
=============================

The ``planetary2d.animator`` module provides utilities for animating
the system of bodies and exporting it to a video file.

Please note that the most important function ``load_json_data`` is present
in the main ``planetary2d`` namespace.

Classes and functions present in ``planetary2d.animator`` listed below.

Animation classes
-----------------
- Animator

Animation functions
-------------------
- animate()

"""

# Imports
from typing import Literal, List, Tuple, Dict
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection  # For trajectories
from matplotlib.animation import FuncAnimation, FFMpegWriter
# from .bodies_system import *
from .bodies_system import SystemOfBodies
from .bodies_system import T_UNITS_INV, S_UNITS_INV, M_UNITS_INV
from .bodies_system import ArrayOfScalars, ScalarType
# For interactive plotting
matplotlib.use(backend="TkAgg")


# Type alias definitions
TrajectoryType = np.ndarray[tuple[int, int], np.dtype[ScalarType]]
"""
The 2nd index have to be 2.
"""


# Global constants for supported output video file formats
SUPPORTED_VIDEO_FMTS: Dict[str, str] = {
    'gif': 'ffmpeg',
    'mp4': 'ffmpeg',
    'avi': 'pillow|imagemagick'
}


class Animator:
    """
    """

    def __init__(self,
                 system: SystemOfBodies,
                 limit: int,
                 frame_rate: int = 10,
                 title: str = 'Animation generated by ``planetary2d``',
                 title_size: int = 16,
                 no_units: bool = False,
                 colors: List[str] = 'gray',
                 traj_colors: List[str] = 'gray',
                 label_size: int = 12,
                 label_color: str = 'gray',
                 linewidths: float | List[float] = 1,
                 dark_bg: bool = True,
                 show_grid: bool = True,
                 grid_color: str = 'gray',
                 show_axes: bool = True,
                 padding: int = 10,
                 use_tex: bool = False,
                 no_show: bool = False,
                 no_save: bool = False) -> None:
        """
        :param frame_rate: Frame rate in fps (frames per second, i.e. Hz)
        :type frame_rate: int
        """
        # == Create data members == (check validity)
        self.system = system
        self.system.limit = limit
        self.frame_rate = frame_rate
        self.title = title
        self.title_size = title_size
        self.no_units = no_units
        self.colors = colors  # Colors of bodies... (check)
        self.traj_colors = traj_colors  # Colors of trajectories... (check)
        self.label_size = label_size  # Size of texts (labels)
        self.label_color = label_color  # Color of texts (labels)
        self.linewidths = linewidths  # Linewidths of trajectories (check)
        self.dark_bg = dark_bg  # Dark background?
        self.show_grid = show_grid
        self.grid_color = grid_color
        self.show_axes = show_axes
        self.padding = padding
        self.use_tex = use_tex
        self.no_show = no_show
        self.no_save = no_save
        self.annotations = []  # List for annotations (labels) for bodies

    def __generate_data(self,
                        frame: SystemOfBodies) -> Tuple[ArrayOfScalars,
                                                        ArrayOfScalars,
                                                        List[TrajectoryType]
                                                        | None]:
        """
        Generates data for plotting. \n
        Returns tuple of X, Y, trajectories, where X, Y are coordinates
        of current positions of bodies and trajectories hold the history of
        positions of bodies if ``no_hist`` attribute is False.
        """
        # Extract positions of bodies from the system of bodies
        X, Y = frame.pos.real, frame.pos.imag
        # Extract trajectories of bodies in the system of bodies
        trajectories = None  # trajectories = None if no_hist = True
        if frame.no_hist is False:
            # Stack list of numpy arrays to one two-dimensional
            # and transpose this 2D array so that positions of one body
            # (trajectories) are ordered along the first axis of the 2D array
            cplx_trajs = np.stack(frame.hist).T
            # Extract coordinates of points
            trajs_X, trajs_Y = cplx_trajs.real, cplx_trajs.imag
            # Create 3D array of shape
            # (bodies_count, num_of_hist_pos_for_bdy, 2)
            trajs_bulk = np.stack((trajs_X, trajs_Y), axis=-1)
            # Create a list of arrays of trajectories of shape
            # (num_of_hist_pos_for_bdy, 2) - equivalent to array of tuples...
            trajectories = [traj for traj in trajs_bulk]
        return X, Y, trajectories

    def __annotate_bodies(self, frame: SystemOfBodies) -> None:
        """
        Adds labels to the positions of bodies. \n
        Note that this method uses ``self.ax`` and ``self.annotations``
        attributes, so it has to be set!
        """
        # Extract positions of bodies from the frame
        X, Y = frame.pos.real, frame.pos.imag
        # Add labels to bodies
        for bdy, label in enumerate(frame.labels):
            annot = self.ax.annotate(label,
                                     # Position of the annotation
                                     (X[bdy], Y[bdy]),
                                     # Color of the text
                                     color=self.label_color,
                                     # Size of the text
                                     fontsize=self.label_size,
                                     # Set the order of artists;
                                     # labels should be at foreground
                                     zorder=3)
            self.annotations.append(annot)

    def __annotate_move(self, X: ArrayOfScalars, Y: ArrayOfScalars) -> None:
        """
        Change positions of labels/annotations to new positions of bodies. \n
        Note that this method uses ``self.annotations`` attribute,
        so it has to be set!
        """
        # Iterate through annotations and change positions
        for i, annot in enumerate(self.annotations):
            annot.set_position((X[i], Y[i]))

    def __update_frame(self, frame: SystemOfBodies):
        """
        Updates frame in the animation.
        """
        # Generate data for plotting
        X, Y, trajectories = self.__generate_data(frame)
        # Change data (offsets) of the scatter plot (move to new positions)
        # (it takes "an array of tuples", shape (n, 2), hence the np.stack)
        self.bodies.set_offsets(np.stack((X, Y), axis=-1))
        # Move the labels to new positions
        self.__annotate_move(X, Y)
        # Change data to the LineCollection if they were to be plotted
        # (add new positions from history)
        if frame.no_hist is False:
            self.trajs.set_segments(trajectories)
        # Re-scale the limits to bigger if necessary
        xlim_min_got, xlim_max_got = self.ax.get_xlim()
        ylim_min_got, ylim_max_got = self.ax.get_ylim()
        xlim_min, xlim_max = np.min(X) - self.padding, np.max(X) + self.padding
        ylim_min, ylim_max = np.min(Y) - self.padding, np.max(Y) + self.padding
        if xlim_min_got > xlim_min or xlim_max_got < xlim_max:
            self.ax.set_xlim(xlim_min, xlim_max)
        if ylim_min_got > ylim_min or ylim_max_got < ylim_max:
            self.ax.set_ylim(ylim_min, ylim_max)
        return self.bodies, self.trajs

    def animate(self):
        """
        Starts the animation based on the settings given in the constructor.
        """
        # Set dark background if required
        if self.dark_bg is True:
            plt.style.use('dark_background')
        # Create a plot
        self.fig, self.ax = plt.subplots()
        # Set title and subtitle with units if required
        self.fig.suptitle(self.title, fontsize=self.title_size)
        if self.no_units is False:
            self.ax.set_title(f"Units of space: "
                              f"{S_UNITS_INV[self.system.s_units]}\n"
                              f"Units of time: "
                              f"{T_UNITS_INV[self.system.t_units]}\n"
                              f"Units of mass: "
                              f"{M_UNITS_INV[self.system.m_units]}",
                              # Align to the center
                              loc='center',
                              # Set fontsize to label_size+2
                              fontsize=self.label_size + 2)
        # Hide axes if required
        if self.show_axes is False:
            self.ax.set_axis_off()
        # Add grid if required
        if self.show_grid is True:
            self.ax.grid(True,
                         color=self.grid_color,
                         linewidth=0.5,
                         linestyle='--')
        # Generate data for plotting
        X, Y, trajectories = self.__generate_data(self.system)
        # Set limits
        self.ax.set_xlim(np.min(X) - self.padding, np.max(X) + self.padding)
        self.ax.set_ylim(np.min(Y) - self.padding, np.max(Y) + self.padding)
        # Plot bodies as a scatter plot
        # (zorder sets how artists would be orderd on the screen;
        #  bodies should be in front of trajectories and behind labels)
        self.bodies = self.ax.scatter(X, Y, zorder=2)
        # Add labels to bodies in the scatter plot
        self.__annotate_bodies(self.system)
        # Plot trajectories as a LineCollection if they are to be plotted
        if self.system.no_hist is False:
            # Settings from ctor are used here
            self.trajs = LineCollection(trajectories,  # List of arrays (n, 2)
                                        # Color of trajectories
                                        colors=self.traj_colors,
                                        # Width of trajectories
                                        linewidths=self.linewidths,
                                        # Set the order of artists;
                                        # trajectories should be at background
                                        zorder=1)
        # Create the animation
        self.anim = FuncAnimation(fig=self.fig,  # Figure to be animated
                                  # Functino to update the frame
                                  func=self.__update_frame,
                                  # Iterable object (system of bodies)
                                  # On iterating, it calculates the next state.
                                  # Stops iteration when limit is reached.
                                  # (see the respective iterator)
                                  frames=self.system,
                                  # Frame rate converted to a period in ms
                                  interval=1000 / self.frame_rate,
                                  # Do not redraw only differences
                                  # (cannot be set with annotations
                                  # and other complex artists!)
                                  blit=False,
                                  # Maximum number of frames that can be cached
                                  save_count=200)
        # Show animation if it has been chosen
        if self.no_show is False:
            plt.show()
        # Reset the style of matplotlib.pyplot
        plt.style.use('default')

    def save_animation(self,
                       path: str,
                       format: Literal['gif', 'mp4', 'avi'] = 'gif',
                       dpi: float = 100,
                       bitrate: int = -1) -> None:
        """
        Does not work if animate() has not been called!

        :param path: Path of the output video file (may be relative). \n
            Note that you must specify the right extension!
            (the ``path`` is treated as is; in fact, this determines format)
        :type path: str

        :param format: Format of the output video file. \n
            *Note that 'mp4' and 'avi' formats require ``ffmpeg`` to
            be installed in your system!*
        :type format: Literal['gif', 'mp4', 'avi']

        :param dpi: Dots per inch
        :type dpi: float

        :param bitrate: Bitrate (-1 means default value of writer)
        :type bitrate: int
        """
        # Check if it is required not to save
        if self.no_save is True:
            raise RuntimeError("Requested operation cannot be performed "
                               "(saving animation disabled in ctor)!")
        # Check if animation has already been created
        elif not hasattr(self, 'anim'):
            raise RuntimeError("Requested operation cannot be performed "
                               "(saving animation before its creation)!")
        # Check proper argument ``format``
        elif format not in SUPPORTED_VIDEO_FMTS.keys():
            raise ValueError("Invalid format of the output video file!")
        # Save
        else:
            #
            metadata = {
                'title': self.title,
                'comment':
                'Video generated by planetary2d'
            }
            if SUPPORTED_VIDEO_FMTS[format] == 'ffmpeg':
                writer = FFMpegWriter(fps=self.frame_rate,
                                      bitrate=bitrate,
                                      metadata=metadata)
                self.anim.save(path, writer=writer, dpi=dpi)
            else:
                self.anim.save(path,
                               fps=self.frame_rate,
                               bitrate=bitrate,
                               dpi=dpi,
                               metadata=metadata)


def animate(necessary_data) -> None:
    """
    Convenience function for animating a system of bodies.
    """
    # Create Animator object
    animator = Animator(necessary_data)
    # Animate
    animator.animate()
    # Save animation if it has been set
    if 'save_animation' in necessary_data:
        animator.save_animation()
