"""
``planetary2d.animator``
========================

The ``planetary2d.animator`` module provides utilities for animating
the system of bodies and exporting it to a video file.

Only ``gif``, ``mp4`` and ``avi`` file types are supported.

Please note that the most important class ``Animator`` and function ``animate``
is present in the main ``planetary2d`` namespace.

Classes and functions present in ``planetary2d.animator`` listed below.

Animation classes
-----------------
- Animator

Animation functions
-------------------
- animate()

"""

# Imports
from typing import Literal, List, Tuple, Dict
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection  # For trajectories
from matplotlib.animation import FuncAnimation, FFMpegWriter
from .bodies_system import SystemOfBodies
from .bodies_system import T_UNITS_INV, S_UNITS_INV, M_UNITS_INV
from .bodies_system import ArrayOfScalars, ScalarType
# For interactive plotting
matplotlib.use(backend="TkAgg")


# Type alias definitions
TrajectoryType = np.ndarray[tuple[int, int], np.dtype[ScalarType]]
"""
The 2nd index have to be 2.
"""


# Global constants for supported output video file formats
SUPPORTED_VIDEO_FMTS: Dict[str, str] = {
    'gif': 'ffmpeg',
    'mp4': 'ffmpeg',
    'avi': 'pillow|imagemagick'
}


class Animator:
    """
    """

    def __init__(self,
                 system: SystemOfBodies,
                 limit: int,
                 frame_rate: int = 10,
                 title: str = 'Animation generated by ``planetary2d``',
                 title_size: int = 16,
                 no_units: bool = False,
                 units_box_color: str = 'lightgray',
                 colors: List[str] = 'gray',
                 markersize: List[float] = 10,
                 traj_colors: List[str] = 'gray',
                 linewidths: float | List[float] = 1,
                 label_size: int = 12,
                 label_color: str = 'gray',
                 dark_bg: bool = True,
                 show_grid: bool = True,
                 grid_color: str = 'gray',
                 show_axes: bool = True,
                 padding: float = 0.1,
                 xlimits: Tuple[float, float] = None,
                 ylimits: Tuple[float, float] = None,
                 no_show: bool = False,
                 no_save: bool = False) -> None:
        """
        Constructor of the 

        :param frame_rate: Frame rate in fps (frames per second, i.e. Hz)
        :type frame_rate: int
        """
        # == Create data members == (check validity)
        self.system = system
        self.system.limit = limit
        self.frame_rate = frame_rate
        self.title = title
        self.title_size = title_size
        self.no_units = no_units
        self.units_box_color = units_box_color
        self.colors = colors  # Colors of bodies... (check)
        self.markersize = markersize  # Markersizes of bodies... (check)
        self.traj_colors = traj_colors  # Colors of trajectories... (check)
        self.label_size = label_size  # Size of texts (labels)
        self.label_color = label_color  # Color of texts (labels)
        self.linewidths = linewidths  # Linewidths of trajectories (check)
        self.dark_bg = dark_bg  # Dark background?
        self.show_grid = show_grid
        self.grid_color = grid_color
        self.show_axes = show_axes
        self.padding = padding  # Relative value!!!
        self.xlimits = xlimits  # Initial xlimits of the frames
        self.ylimits = ylimits  # Initial ylimits of the frames
        self.no_show = no_show
        self.no_save = no_save
        self.annotations = []  # List for annotations (labels) for bodies
        # Create the animation
        self.__create_animation()

    def __init_units(self) -> None:
        """
        Add a legend of units to the figure. It creates attribute
        ``self.units_label``. \n
        Note that this method uses ``self.ax``, ``self.label_size``,
        ``self.system.s_units``, ``self.system.t_units``,
        ``self.system.m_units`` and ``self.units_box_color`` attributes,
        so it has to be set!
        """
        self.units_label = self.ax.text(0.03, 0.95,  # Relative position
                                        # The text to display
                                        f"Units:\n"
                                        f"- space: "
                                        f"{S_UNITS_INV[self.system.s_units]}\n"
                                        f"- time: "
                                        f"{T_UNITS_INV[self.system.t_units]}\n"
                                        f"- mass: "
                                        f"{M_UNITS_INV[self.system.m_units]}",
                                        # Use relative coordinates
                                        transform=self.ax.transAxes,
                                        # Set fontsize to label_size+2
                                        fontsize=self.label_size,
                                        # Align text vertically
                                        verticalalignment='top',
                                        # Align text horizontally
                                        horizontalalignment='left',
                                        # Style of the box
                                        bbox=dict(boxstyle='round,pad=0.3',
                                                  facecolor=self.units_box_color,
                                                  alpha=0.3))

    def __generate_data(self,
                        frame: SystemOfBodies) -> Tuple[ArrayOfScalars,
                                                        ArrayOfScalars,
                                                        List[TrajectoryType]
                                                        | None]:
        """
        Generates data for plotting. \n
        Returns tuple of X, Y, trajectories, where X, Y are coordinates
        of current positions of bodies and trajectories hold the history of
        positions of bodies if ``no_hist`` attribute is False.
        """
        # Extract positions of bodies from the system of bodies
        X, Y = frame.pos.real, frame.pos.imag
        # Extract trajectories of bodies in the system of bodies
        trajectories = None  # trajectories = None if no_hist = True
        if frame.no_hist is False:
            # Stack list of numpy arrays to one two-dimensional
            # and transpose this 2D array so that positions of one body
            # (trajectories) are ordered along the first axis of the 2D array
            cplx_trajs = np.stack(frame.hist).T
            # Extract coordinates of points
            trajs_X, trajs_Y = cplx_trajs.real, cplx_trajs.imag
            # Create 3D array of shape
            # (bodies_count, num_of_hist_pos_for_bdy, 2)
            trajs_bulk = np.stack((trajs_X, trajs_Y), axis=-1)
            # Create a list of arrays of trajectories of shape
            # (num_of_hist_pos_for_bdy, 2) - equivalent to array of tuples...
            trajectories = [traj for traj in trajs_bulk]
        return X, Y, trajectories

    def __annotate_bodies(self, frame: SystemOfBodies) -> None:
        """
        Adds labels to the positions of bodies. \n
        Note that this method uses ``self.ax`` and ``self.annotations``
        attributes, so it has to be set!
        """
        # Extract positions of bodies from the frame
        X, Y = frame.pos.real, frame.pos.imag
        # Add labels to bodies
        for bdy, label in enumerate(frame.labels):
            annot = self.ax.annotate(label,
                                     # Position of the annotation
                                     (X[bdy], Y[bdy]),
                                     # Color of the text
                                     color=self.label_color,
                                     # Size of the text
                                     fontsize=self.label_size,
                                     # Set the order of artists;
                                     # labels should be at foreground
                                     zorder=4)
            self.annotations.append(annot)

    def __annotate_move(self, X: ArrayOfScalars, Y: ArrayOfScalars) -> None:
        """
        Change positions of labels/annotations to new positions of bodies. \n
        Note that this method uses ``self.annotations`` attribute,
        so it has to be set!
        """
        # Iterate through annotations and change positions
        for i, annot in enumerate(self.annotations):
            annot.set_position((X[i], Y[i]))

    def __determine_limits(self,
                           X: ArrayOfScalars,
                           Y: ArrayOfScalars) -> Tuple[float, float,
                                                       float, float]:
        """
        Recalculates minimal limits that the plot should have.
        """
        xlim_min, xlim_max = np.min(X), np.max(X)
        xlim_dif = xlim_max - xlim_min
        xpadding = xlim_dif * self.padding
        xlim_min, xlim_max = xlim_min - xpadding, xlim_max + xpadding
        ylim_min, ylim_max = np.min(Y), np.max(Y)
        ylim_dif = ylim_max - ylim_min
        ypadding = ylim_dif * self.padding
        ylim_min, ylim_max = ylim_min - ypadding, ylim_max + ypadding
        return xlim_min, xlim_max, ylim_min, ylim_max

    def __init_limits(self, X: ArrayOfScalars, Y: ArrayOfScalars) -> None:
        """
        Initializes limits for plots. If initial limits are set
        (attributes: ``xlimits``, ``ylimits``) they may be used
        if they are big enough. \n
        Note that this method uses ``self.ax`` attribute,
        so it has to be set!
        """
        # Find necessary limits
        xlim_min, xlim_max, ylim_min, ylim_max = self.__determine_limits(X, Y)
        # Choose the bigger of the required and the necessary x limits
        if self.xlimits is not None:
            xlim_min_set, xlim_max_set = self.xlimits
            if xlim_min_set < xlim_min:
                xlim_min = xlim_min_set
            if xlim_max_set > xlim_max:
                xlim_max = xlim_max_set
        # Choose the bigger of the required and the necessary y limits
        if self.ylimits is not None:
            ylim_min_set, ylim_max_set = self.ylimits
            if ylim_min_set < ylim_min:
                ylim_min = ylim_min_set
            if ylim_max_set > ylim_max:
                ylim_max = ylim_max_set
        # Set limits
        self.ax.set_xlim(xlim_min, xlim_max)
        self.ax.set_ylim(ylim_min, ylim_max)

    def __init_scatter(self, X: ArrayOfScalars, Y: ArrayOfScalars) -> None:
        """
        Add scatter plot to axis. It creates attribute ``self.bodies``. \n
        Note that this method uses ``self.ax`` attribute,
        so it has to be set!
        """
        self.bodies = self.ax.scatter(X, Y,  # Coordinates
                                      # Set how artists would be orderd
                                      # on the screen; bodies should be
                                      # in front of trajectories
                                      # and behind labels
                                      zorder=3,
                                      # Colors of bodies
                                      c=self.colors,
                                      # Marker sizes
                                      s=self.markersize)

    def __init_trajectories(self,
                            trajectories: List[TrajectoryType] | None) -> None:
        """
        Add LineCollection plot to axis. It creates attribute
        ``self.trajs``. \n
        Note that this method uses ``self.ax``, ``self.system.no_hist``,
        ``self.traj_colors`` and ``self.linewidths`` attributes,
        so it has to be set!
        """
        # Plot trajectories as a LineCollection if they are to be plotted
        if self.system.no_hist is False:
            # Settings from ctor are used here
            self.trajs = LineCollection(trajectories,  # List of arrays (n, 2)
                                        # Color of trajectories
                                        colors=self.traj_colors,
                                        # Width of trajectories
                                        linewidths=self.linewidths,
                                        # Set the order of artists;
                                        # trajectories should be at background
                                        zorder=1)
            # Add the collection of trajectories to the axis
            self.ax.add_collection(self.trajs)

    def __update_frame(self, frame: SystemOfBodies):
        """
        Updates frame in the animation.
        """
        # Generate data for plotting
        X, Y, trajectories = self.__generate_data(frame)
        # Change data (offsets) of the scatter plot (move to new positions)
        # (it takes "an array of tuples", shape (n, 2), hence the np.stack)
        self.bodies.set_offsets(np.stack((X, Y), axis=-1))
        # Move the labels to new positions
        self.__annotate_move(X, Y)
        # Change data to the LineCollection if they were to be plotted
        # (add new positions from history)
        if frame.no_hist is False:
            self.trajs.set_segments(trajectories)
        # Re-scale the limits to bigger if necessary
        xlim_min_got, xlim_max_got = self.ax.get_xlim()  # Get current limits
        ylim_min_got, ylim_max_got = self.ax.get_ylim()
        xlim_min, xlim_max, ylim_min, ylim_max = self.__determine_limits(X, Y)
        xlim_min_set, xlim_max_set = xlim_min_got, xlim_max_got  # Limits to set
        ylim_min_set, ylim_max_set = ylim_min_got, ylim_max_got
        if xlim_min_got > xlim_min:  # Change only those which differ
            xlim_min_set = xlim_min
        if xlim_max_got < xlim_max:
            xlim_max_set = xlim_max
        if ylim_min_got > ylim_min:
            ylim_min_set = ylim_min
        if ylim_max_got < ylim_max:
            ylim_max_set = ylim_max
        if xlim_min_got > xlim_min or xlim_max_got < xlim_max:  # Re-scale
            self.ax.set_xlim(xlim_min_set, xlim_max_set)
        if ylim_min_got > ylim_min or ylim_max_got < ylim_max:
            self.ax.set_ylim(ylim_min_set, ylim_max_set)
        return self.bodies, self.trajs

    def __create_animation(self) -> None:
        """
        Creates the animation based on the settings given in the constructor.
        """
        # Set dark background if required
        if self.dark_bg is True:
            plt.style.use('dark_background')
        # Create a plot
        self.fig, self.ax = plt.subplots()
        # Set title
        self.fig.suptitle(self.title, fontsize=self.title_size)
        # Add units if not disabled
        if self.no_units is False:
            self.__init_units()
        # Hide axes if required
        if self.show_axes is False:
            self.ax.set_axis_off()
        # Add grid if required
        if self.show_grid is True:
            self.ax.grid(True, color=self.grid_color,
                         linewidth=0.5, linestyle='--')
        # Generate data for plotting
        X, Y, trajectories = self.__generate_data(self.system)
        # Set limits
        self.__init_limits(X, Y)
        # Create a scatter plot (bodies)
        self.__init_scatter(X, Y)
        # Add labels to bodies in the scatter plot
        self.__annotate_bodies(self.system)
        # Plot trajectories as a LineCollection if they are to be plotted
        self.__init_trajectories(trajectories)
        # Create the animation
        self.anim = FuncAnimation(fig=self.fig,  # Figure to be animated
                                  # Functino to update the frame
                                  func=self.__update_frame,
                                  # Iterable object (system of bodies)
                                  # On iterating, it calculates the next state.
                                  # Stops iteration when limit is reached.
                                  # (see the respective iterator)
                                  frames=self.system,
                                  # Frame rate converted to a period in ms
                                  interval=1000 / self.frame_rate,
                                  # Do not redraw only differences
                                  # (cannot be set with annotations
                                  # and other complex artists!)
                                  blit=False,
                                  # Maximum number of frames that can be cached
                                  save_count=200)

    def show(self) -> None:
        """
        Show animation based on the information from the constructor.
        """
        # Show animation if it has been chosen
        if self.no_show is True:
            raise RuntimeError("Requested operation cannot be performed "
                               "(showing animation disabled in ctor)!")
        # Check if animation has already been created (this should never occur)
        elif not hasattr(self, 'anim'):
            raise RuntimeError("Requested operation cannot be performed "
                               "(saving animation before its creation)!")
        else:
            # Creates animation anew if its been shown once
            if self.anim is None:
                self.__create_animation()
            # Display the animation (and it destroys it as well)
            plt.show()
            # Mark self.anim attribute as exhausted
            self.anim = None

    def save(self,
             path: str,
             format: Literal['gif', 'mp4', 'avi'] = 'gif',
             dpi: float = 100,
             bitrate: int = -1) -> None:
        """
        Saves the animation. \n
        Codec of the output video is selected according to the extension of
        the file by the writer.

        :param path: Path of the output video file (may be relative). \n
            Note that you must specify the right extension!
            (the ``path`` is treated as is; in fact, this determines format)
        :type path: str

        :param format: Format of the output video file. \n
            *Note that 'mp4' and 'avi' formats require ``ffmpeg`` to
            be installed in your system!*
        :type format: Literal['gif', 'mp4', 'avi']

        :param dpi: Dots per inch
        :type dpi: float

        :param bitrate: Bitrate (-1 means default value of writer)
        :type bitrate: int
        """
        # Check if it is required not to save
        if self.no_save is True:
            raise RuntimeError("Requested operation cannot be performed "
                               "(saving animation disabled in ctor)!")
        # Check if animation has already been created (this should never occur)
        elif not hasattr(self, 'anim'):
            raise RuntimeError("Requested operation cannot be performed "
                               "(saving animation before its creation)!")
        # Check proper argument ``format``
        elif format not in SUPPORTED_VIDEO_FMTS.keys():
            raise ValueError("Invalid format of the output video file!")
        # Save
        else:
            # Set metadata
            metadata = {
                'title': self.title,
                'comment':
                'Video generated by planetary2d'
            }
            # Save the video by 'ffmpeg' or by other default
            if SUPPORTED_VIDEO_FMTS[format] == 'ffmpeg':
                # Set the writer
                writer = FFMpegWriter(fps=self.frame_rate,
                                      bitrate=bitrate,
                                      metadata=metadata)
                # Save the file
                self.anim.save(path, writer=writer, dpi=dpi)
            else:
                # Save the file
                self.anim.save(path,
                               fps=self.frame_rate,
                               bitrate=bitrate,
                               dpi=dpi,
                               metadata=metadata)


def animate(necessary_data) -> None:
    """
    Convenience function for animating a system of bodies.
    """
    # TODO:
    # Create Animator object
    animator = Animator(necessary_data)
    # Animate
    animator.show()
    # Save animation if it has been set
    if 'save_animation' in necessary_data:
        animator.save_animation()
