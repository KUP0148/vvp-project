"""
``planetary2d.animator``
=============================

The ``planetary2d.animator`` module provides utilities for animating
the system of bodies and exporting it to a video file.

Please note that the most important function ``load_json_data`` is present
in the main ``planetary2d`` namespace.

Classes and functions present in ``planetary2d.animator`` listed below.

Animation classes
-----------------
- Animator

Animation functions
-------------------
- animate()

"""

# Imports
from typing import Literal, List, Tuple
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection  # For trajectories
from matplotlib.animation import FuncAnimation
# from .bodies_system import *
from .bodies_system import SystemOfBodies
from .bodies_system import __T_UNITS_INV, __S_UNITS_INV, __M_UNITS_INV
from .bodies_system import ArrayOfVectors, ArrayOfScalars, ScalarType
# For interactive plotting
matplotlib.use(backend="TkAgg")


# Type alias definitions
TrajectoryType = np.ndarray[tuple[int, int], np.dtype[ScalarType]]
"""
The 2nd index have to be 2.
"""


class Animator:
    """
    """

    def __init__(self,
                 system: SystemOfBodies,
                 limit: int,
                 frame_rate: int = 10,
                 title: str = 'Animation generated by ``planetary2d``',
                 colors: List[str] = 'gray',
                 traj_colors: List[str] = 'gray',
                 text_color: str = 'gray',
                 linewidths: float | List[float] = 1,
                 dark_bg: bool = True,
                 use_tex: bool = False,
                 no_show: bool = False,
                 no_save: bool = False) -> None:
        """
        :param frame_rate: Frame rate in fps (frames per second, i.e. Hz)
        :type frame_rate: int
        """
        # == Create data members == (check validity)
        self.system = system
        self.system.limit = limit
        self.frame_rate = frame_rate
        self.title = title
        self.colors = colors  # Colors of bodies... (check)
        self.traj_colors = traj_colors  # Colors of trajectories... (check)
        self.text_color = text_color  # Color of texts (labels)
        self.linewidths = linewidths  # Linewidths of trajectories (check)
        self.dark_bg = dark_bg  # Dark background?
        self.use_tex = use_tex
        self.no_show = no_show
        self.no_save = no_save
        self.annotations = []  # List for annotations (labels) for bodies

    def __generate_data(self,
                        frame: SystemOfBodies) -> Tuple[ArrayOfScalars,
                                                        ArrayOfScalars,
                                                        List[TrajectoryType]
                                                        | None]:
        """
        Generates data for plotting. \n
        Returns tuple of X, Y, trajectories, where X, Y are coordinates
        of current positions of bodies and trajectories hold the history of
        positions of bodies if ``no_hist`` attribute is False.
        """
        # Extract positions of bodies from the system of bodies
        X, Y = frame.pos.real, frame.pos.imag
        # Extract trajectories of bodies in the system of bodies
        trajectories = None  # trajectories = None if no_hist = True
        if frame.no_hist is False:
            # Stack list of numpy arrays to one two-dimensional
            # and transpose this 2D array so that positions of one body
            # (trajectories) are ordered along the first axis of the 2D array
            cplx_trajs = np.stack(frame.hist).T
            # Extract coordinates of points
            trajs_X, trajs_Y = cplx_trajs.real, cplx_trajs.imag
            # Create 3D array of shape
            # (bodies_count, num_of_hist_pos_for_bdy, 2)
            trajs_bulk = np.stack((trajs_X, trajs_Y), axis=-1)
            # Create a list of arrays of trajectories of shape
            # (num_of_hist_pos_for_bdy, 2) - equivalent to array of tuples...
            trajectories = [traj for traj in trajs_bulk]
        return X, Y, trajectories

    def __anotate_bodies(self,
                         frame: SystemOfBodies) -> None:
        """
        Adds labels to the positions of bodies. \n
        Note that this method uses ``self.ax`` and ``self.annotations``
        attributes, so it has to be set!
        """
        # Extract positions of bodies from the frame
        X, Y = frame.pos.real, frame.pos.imag
        # Add labels to bodies
        for bdy, label in enumerate(frame.labels):
            annot = self.ax.annotate(label,
                                     # Position of the annotation
                                     (X[bdy], Y[bdy]),
                                     # Treat xytext relative to position
                                     textcoords="offset points",
                                     # Position of the text
                                     xytext=(5, 5),
                                     # Horizontal alignment of the text
                                     ha='left',
                                     # Color of the text
                                     color=self.text_color)
            self.annotations.append(annot)

    def __update_frame(self, frame: SystemOfBodies):
        """
        """
        # self.trajectories.set_xdata(X)
        # ==========================================
        # Generate data for plotting
        X, Y, trajectories = self.__generate_data(frame)
        # Change data (offsets) of the scatter plot
        # (it takes "an array of tuples", shape (n, 2), hence the np.stack)
        self.bodies.set_offsets(np.stack((X, Y), axis=-1))
        # Add labels to bodies in the scatter plot
        self.__anotate_bodies(frame)
        # Plot trajectories as a LineCollection if they are to be plotted
        if frame.no_hist is False:
            # Settings from ctor are used here
            self.trajs = LineCollection(trajectories,  # List of arrays (n, 2)
                                        colors=self.traj_colors,
                                        linewidths=self.linewidths)
        return self.bodies, self.trajs

    def animate(self):
        """
        """
        # Set dark background if required
        if self.dark_bg is True:
            plt.style.use('dark_background')
        # Create a plot
        self.fig, self.ax = plt.subplots()
        # Set title
        self.ax.set_title(self.title)
        # Generate data for plotting
        X, Y, trajectories = self.__generate_data(self.system)
        # Plot bodies as a scatter plot
        self.bodies = self.ax.scatter(X, Y)
        # Add labels to bodies in the scatter plot
        self.__anotate_bodies(self.system, self.ax)
        # Plot trajectories as a LineCollection if they are to be plotted
        if self.system.no_hist is False:
            # Settings from ctor are used here
            self.trajs = LineCollection(trajectories,  # List of arrays (n, 2)
                                        colors=self.traj_colors,
                                        linewidths=self.linewidths)
        # Create the animation
        self.anim = FuncAnimation(fig=self.fig,  # Figure to be animated
                                  func=self.__update_frame,  # Update func
                                  frames=self.system,  # Iterable object
                                  interval=1000 / self.frame_rate,  # [ms]
                                  blit=True)  # Redraw only differences
        # Show animation if it has been chosen
        if self.no_show is False:
            plt.show()

    def save_animation(self, path: str, format: Literal['gif', 'mp4']) -> None:
        """
        Cannot be saved if animate() has not been called!
        """
        if self.no_save is True:
            _MSG_GENERAL = "Requested operation cannot be performed"
            _MSG_SPECIFIC = "(animation disabled in ctor)"
            raise RuntimeError(f"{_MSG_GENERAL} {_MSG_SPECIFIC}.")
        else:
            # Save it
            pass


def animate(necessary_data) -> None:
    """
    Convenience function for animating a system of bodies.
    """
    # Create Animator object
    animator = Animator(necessary_data)
    # Animate
    animator.animate()
    # Save animation if it has been set
    if 'save_animation' in necessary_data:
        animator.save_animation()
