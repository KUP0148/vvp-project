"""
``planetary2d.animator``
========================

The ``planetary2d.animator`` module provides utilities for animating
the system of bodies and exporting it to a video file.

Only ``gif``, ``mp4`` and ``avi`` file types are supported.

Please note that the most important class ``Animator`` and function ``animate``
is present in the main ``planetary2d`` namespace.

Classes and functions present in ``planetary2d.animator`` listed below.

Animation classes
-----------------
- Animator

Animation functions
-------------------
- animate()

Animation constants
-------------------
- SUPPORTED_VIDEO_FMTS

Animation type aliases
----------------------
- TrajectoryType

"""

# Imports
from typing import Literal, List, Tuple, Dict
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection  # For trajectories
from matplotlib.animation import FuncAnimation, FFMpegWriter
from .bodies_system import SystemOfBodies
from .bodies_system import T_UNITS_INV, S_UNITS_INV, M_UNITS_INV
from .bodies_system import ArrayOfScalars, ScalarType
# For interactive plotting
matplotlib.use(backend="TkAgg")


# Type alias definitions
TrajectoryType = np.ndarray[tuple[int, int], np.dtype[ScalarType]]
"""
The 2nd index have to be 2.
"""


# Global constants for supported output video file formats
SUPPORTED_VIDEO_FMTS: Dict[str, str] = {
    'gif': 'ffmpeg',
    'mp4': 'ffmpeg',
    'avi': 'pillow|imagemagick'
}


class Animator:
    """
    A class which handles animations of systems of bodies.

    TODO: Add attributes docstrings...!
    """

    def __init__(self,
                 system: SystemOfBodies,
                 limit: int,
                 title: str = 'Animation generated by planetary2d',
                 title_size: int = 16,
                 no_units: bool = False,
                 units_box_color: str = 'green',
                 bdy_colors: List[str] | str = 'gray',
                 bdy_sizes: List[float] | float = 10,
                 label_size: int = 12,
                 label_color: str = 'lightgray',
                 traj_colors: List[str] | str = 'gray',
                 traj_widths: List[float] | float = 1,
                 dark_bg: bool = True,
                 show_grid: bool = True,
                 grid_color: str = 'gray',
                 padding: float = 0.1,
                 xlimits: Tuple[float, float] = None,
                 ylimits: Tuple[float, float] = None,
                 show_axes: bool = True,
                 frame_rate: int = 10,
                 no_show: bool = False,
                 no_save: bool = False) -> None:
        """
        Constructor of the Animator class. \n
        *Note that most of the arguments have no checking of validity,
        and so can work but need not as well! It depends on matplotlib
        parameters they represent.*

        :param system: System of bodies to be animated.
        :type system: SystemOfBodies

        :param limit: Maximum number of changes of the system of bodies which
            can be performed (i.e. only this number of steps can be done).
        :type limit: int

        :param title: Title for the animation.
        :type title: str

        :param title_size: Size of the title for the animation.
        :type title_size: int

        :param no_units: Boolean switch for disabling a legend of
            units used in the animation.
        :type no_units: bool

        :param units_box_color: Setting the color of the box in which
            the units legend is enclosed. \n
            *Note that this is meaningful only if ``no_units`` = False.*
        :type units_box_color: str

        :param bdy_colors: Colors of bodies. \n
            Note that the list of colors must have the same number of elements
            as the bodies in the system. (PS: if argument is of type ``str``,
            the color is used for all bodies)
        :type bdy_colors: List[str] | str

        :param bdy_sizes: Sizes of bodies. \n
            Note that the list of sizes must have the same number of elements
            as the bodies in the system. (PS: if argument is of type ``float``,
            the size is used for all bodies)
        :type bdy_sizes: List[float] | float

        :param label_size: Sizes of labels for bodies.
        :type label_size: int

        :param label_color: Color of labels for bodies.
        :type label_color: str

        :param traj_colors: Colors of trajectories. \n
            Note that the list of colors must have the same number of elements
            as the bodies (trajectories) in the system. (PS: if argument is
            of type ``str``, the color is used for all bodies)
        :type traj_colors: List[str] | str

        :param traj_widths: Linewidths of trajectories. \n
            Note that the list of linewidths must have the same number of
            elements as the bodies (trajectories) in the system. (PS: if
            argument is of type ``float``, the linewidth is used for
            all bodies)
        :type traj_widths: List[float] | float

        :param dark_bg: Boolean switch for enabling the dark background style.
        :type dark_bg: bool

        :param show_grid: Boolean switch for displaying a grid.
        :type show_grid: bool

        :param grid_color: Color of grid at the background of
            the system of bodies.
        :type grid_color: str

        :param padding: Padding of the screen for the system of bodies. \n
            *Note that this is a relative value with respect to the area
            which is occupied by the plot itself.*
        :type padding: float

        :param xlimits: Tuple of the minimum value and the maximum value which
            on the x-axis. \n
            *Note that these values are overriden by natural sizes of
            the drawing while it is updated according to the evolution
            of the animation (if it grows in size, limits are extended).*
        :type xlimits: Tuple[float, float]

        :param ylimits: Tuple of the minimum value and the maximum value which
            on the y-axis. \n
            *Note that these values are overriden by natural sizes of
            the drawing while it is updated according to the evolution
            of the animation (if it grows in size, limits are extended).*
        :type ylimits: Tuple[float, float]

        :param show_axes: Boolean switch for displaying the axes.
        :type show_axes: bool

        :param frame_rate: Frame rate in fps (frames per second, i.e. Hz).
        :type frame_rate: int

        :param no_show: Boolean switch for disabling the functionality to show
            the animation when calling the method ``show`` (if calling ``show``
            with ``no_show`` = True, it raises a RuntimeError).
        :type no_show: bool

        :param no_save: Boolean switch for disabling the functionality to save
            the animation when calling the method ``save`` (if calling ``save``
            with ``no_save`` = True, it raises a RuntimeError).
        :type no_save: bool
        """
        # == Check data types of parameters ==
        if not isinstance(system, SystemOfBodies):
            raise ValueError("Invalid argument type: "
                             "'system' must be of type 'SystemOfBodies'")
        if not isinstance(limit, int):
            raise ValueError("Invalid argument type: "
                             "'limit' must be of type 'int'")
        if not isinstance(title, str):
            raise ValueError("Invalid argument type: "
                             "'title' must be of type 'str'")
        if not isinstance(title_size, int):
            raise ValueError("Invalid argument type: "
                             "'title_size' must be of type 'int'")
        if not isinstance(no_units, bool):
            raise ValueError("Invalid argument type: "
                             "'no_units' must be of type 'bool'")
        # units_box_color not checked
        if isinstance(bdy_colors, list) and len(bdy_colors) != system.b_num:
            raise ValueError("Invalid argument type: "
                             "'bdy_colors' must have the same number of "
                             "elements as the system has bodies.")
        if isinstance(bdy_sizes, list) and len(bdy_sizes) != system.b_num:
            raise ValueError("Invalid argument type: "
                             "'bdy_sizes' must have the same number of "
                             "elements as the system has bodies.")
        if not isinstance(label_size, int):
            raise ValueError("Invalid argument type: "
                             "'label_size' must be of type 'int'")
        # label_color not checked
        if isinstance(traj_colors, list) and len(traj_colors) != system.b_num:
            raise ValueError("Invalid argument type: "
                             "'traj_colors' must have the same number of "
                             "elements as the system has bodies.")
        if isinstance(traj_widths, list) and len(traj_widths) != system.b_num:
            raise ValueError("Invalid argument type: "
                             "'traj_widths' must have the same number of "
                             "elements as the system has bodies.")
        if not isinstance(dark_bg, bool):
            raise ValueError("Invalid argument type: "
                             "'dark_bg' must be of type 'bool'")
        if not isinstance(show_grid, bool):
            raise ValueError("Invalid argument type: "
                             "'show_grid' must be of type 'bool'")
        # grid_color not checked
        if not isinstance(padding, float):
            raise ValueError("Invalid argument type: "
                             "'padding' must be of type 'float'")
        if ((not isinstance(xlimits, tuple) or len(xlimits) != 2
                or not isinstance(xlimits[0], float)
                or not isinstance(xlimits[1], float))
                and (xlimits is not None)):
            raise ValueError("Invalid argument type: "
                             "'xlimits' must be of type 'Tuple[float, float]'")
        if ((not isinstance(ylimits, tuple) or len(ylimits) != 2
                or not isinstance(ylimits[0], float)
                or not isinstance(ylimits[1], float))
                and (ylimits is not None)):
            raise ValueError("Invalid argument type: "
                             "'ylimits' must be of type 'Tuple[float, float]'")
        if not isinstance(show_axes, bool):
            raise ValueError("Invalid argument type: "
                             "'show_axes' must be of type 'bool'")
        if not isinstance(frame_rate, int):
            raise ValueError("Invalid argument type: "
                             "'frame_rate' must be of type 'int'")
        if not isinstance(no_show, bool):
            raise ValueError("Invalid argument type: "
                             "'no_show' must be of type 'bool'")
        if not isinstance(no_save, bool):
            raise ValueError("Invalid argument type: "
                             "'no_save' must be of type 'bool'")
        # == Create data members ==
        self.system = system
        self.system.limit = limit
        self.title = title
        self.title_size = title_size
        self.no_units = no_units
        self.units_box_color = units_box_color
        self.bdy_colors = bdy_colors
        self.bdy_sizes = bdy_sizes
        self.label_size = label_size
        self.label_color = label_color
        self.traj_colors = traj_colors
        self.traj_widths = traj_widths
        self.dark_bg = dark_bg
        self.show_grid = show_grid
        self.grid_color = grid_color
        self.padding = padding
        self.xlimits = xlimits
        self.ylimits = ylimits
        self.show_axes = show_axes
        self.frame_rate = frame_rate
        self.no_show = no_show
        self.no_save = no_save
        # == Create the animation ==
        self.__create_animation()

    def __init_units(self) -> None:
        """
        Add a legend of units to the figure. It creates attribute
        ``self.units_label``. \n
        Note that this method uses ``self.ax``, ``self.label_size``,
        ``self.system.s_units``, ``self.system.t_units``,
        ``self.system.m_units`` and ``self.units_box_color`` attributes,
        so it has to be set!
        """
        self.units_label = self.ax.text(0.03, 0.95,  # Relative position
                                        # The text to display
                                        f"Units:\n"
                                        f"- space: "
                                        f"{S_UNITS_INV[self.system.s_units]}\n"
                                        f"- time: "
                                        f"{T_UNITS_INV[self.system.t_units]}\n"
                                        f"- mass: "
                                        f"{M_UNITS_INV[self.system.m_units]}",
                                        # Use relative coordinates
                                        transform=self.ax.transAxes,
                                        # Set fontsize to label_size+2
                                        fontsize=self.label_size,
                                        # Align text vertically
                                        verticalalignment='top',
                                        # Align text horizontally
                                        horizontalalignment='left',
                                        # Style of the box
                                        bbox=dict(
                                            boxstyle='round,pad=0.3',
                                            facecolor=self.units_box_color,
                                            alpha=0.3))

    def __generate_data(self,
                        frame: SystemOfBodies) -> Tuple[ArrayOfScalars,
                                                        ArrayOfScalars,
                                                        List[TrajectoryType]
                                                        | None]:
        """
        Generates data for plotting. \n
        Returns tuple of X, Y, trajectories, where X, Y are coordinates
        of current positions of bodies and trajectories hold the history of
        positions of bodies if ``no_hist`` attribute is False.
        """
        # Extract positions of bodies from the system of bodies
        X, Y = frame.pos.real, frame.pos.imag
        # Extract trajectories of bodies in the system of bodies
        trajectories = None  # trajectories = None if no_hist = True
        if frame.no_hist is False:
            # Stack list of numpy arrays to one two-dimensional
            # and transpose this 2D array so that positions of one body
            # (trajectories) are ordered along the first axis of the 2D array
            cplx_trajs = np.stack(frame.hist).T
            # Extract coordinates of points
            trajs_X, trajs_Y = cplx_trajs.real, cplx_trajs.imag
            # Create 3D array of shape
            # (bodies_count, num_of_hist_pos_for_bdy, 2)
            trajs_bulk = np.stack((trajs_X, trajs_Y), axis=-1)
            # Create a list of arrays of trajectories of shape
            # (num_of_hist_pos_for_bdy, 2) - equivalent to array of tuples...
            trajectories = [traj for traj in trajs_bulk]
        return X, Y, trajectories

    def __annotate_bodies(self, frame: SystemOfBodies) -> None:
        """
        Adds labels to the positions of bodies. It creates attribute
        ``self.annotations``. \n
        Note that this method uses ``self.ax``, ``self.label_color``
        and ``self.label_size`` attributes, so it has to be set!
        """
        # List of annotations (labels) for bodies
        self.annotations = []
        # Extract positions of bodies from the frame
        X, Y = frame.pos.real, frame.pos.imag
        # Add labels to bodies
        for bdy, label in enumerate(frame.labels):
            annot = self.ax.annotate(label,
                                     # Position of the annotation
                                     (X[bdy], Y[bdy]),
                                     # Color of the text
                                     color=self.label_color,
                                     # Size of the text
                                     fontsize=self.label_size,
                                     # Set the order of artists;
                                     # labels should be at foreground
                                     zorder=4)
            self.annotations.append(annot)

    def __annotate_move(self, X: ArrayOfScalars, Y: ArrayOfScalars) -> None:
        """
        Change positions of labels/annotations to new positions of bodies. \n
        Note that this method uses ``self.annotations`` attribute,
        so it has to be set!
        """
        # Iterate through annotations and change positions
        for i, annot in enumerate(self.annotations):
            annot.set_position((X[i], Y[i]))

    def __determine_limits(self,
                           X: ArrayOfScalars,
                           Y: ArrayOfScalars) -> Tuple[float, float,
                                                       float, float]:
        """
        Recalculates minimal limits that the plot should have.
        """
        xlim_min, xlim_max = np.min(X), np.max(X)
        xlim_dif = xlim_max - xlim_min
        xpadding = xlim_dif * self.padding
        xlim_min, xlim_max = xlim_min - xpadding, xlim_max + xpadding
        ylim_min, ylim_max = np.min(Y), np.max(Y)
        ylim_dif = ylim_max - ylim_min
        ypadding = ylim_dif * self.padding
        ylim_min, ylim_max = ylim_min - ypadding, ylim_max + ypadding
        return xlim_min, xlim_max, ylim_min, ylim_max

    def __init_limits(self, X: ArrayOfScalars, Y: ArrayOfScalars) -> None:
        """
        Initializes limits for plots. If initial limits are set
        (attributes: ``xlimits``, ``ylimits``) they may be used
        if they are big enough. \n
        Note that this method uses ``self.ax`` attribute,
        so it has to be set!
        """
        # Find necessary limits
        xlim_min, xlim_max, ylim_min, ylim_max = self.__determine_limits(X, Y)
        # Choose the bigger of the required and the necessary x limits
        if self.xlimits is not None:
            xlim_min_set, xlim_max_set = self.xlimits
            if xlim_min_set < xlim_min:
                xlim_min = xlim_min_set
            if xlim_max_set > xlim_max:
                xlim_max = xlim_max_set
        # Choose the bigger of the required and the necessary y limits
        if self.ylimits is not None:
            ylim_min_set, ylim_max_set = self.ylimits
            if ylim_min_set < ylim_min:
                ylim_min = ylim_min_set
            if ylim_max_set > ylim_max:
                ylim_max = ylim_max_set
        # Set limits
        self.ax.set_xlim(xlim_min, xlim_max)
        self.ax.set_ylim(ylim_min, ylim_max)

    def __init_scatter(self, X: ArrayOfScalars, Y: ArrayOfScalars) -> None:
        """
        Add scatter plot to axis. It creates attribute ``self.bodies``. \n
        Note that this method uses ``self.ax`` attribute,
        so it has to be set!
        """
        self.bodies = self.ax.scatter(X, Y,  # Coordinates
                                      # Set how artists would be orderd
                                      # on the screen; bodies should be
                                      # in front of trajectories
                                      # and behind labels
                                      zorder=3,
                                      # Colors of bodies
                                      c=self.bdy_colors,
                                      # Marker sizes
                                      s=self.bdy_sizes)

    def __init_trajectories(self,
                            trajectories: List[TrajectoryType] | None) -> None:
        """
        Add LineCollection plot to axis. It creates attribute
        ``self.trajs``. \n
        Note that this method uses ``self.ax``, ``self.system.no_hist``,
        ``self.traj_colors`` and ``self.linewidths`` attributes,
        so it has to be set!
        """
        # Plot trajectories as a LineCollection if they are to be plotted
        if self.system.no_hist is False:
            # Settings from ctor are used here
            self.trajs = LineCollection(trajectories,  # List of arrays (n, 2)
                                        # Color of trajectories
                                        colors=self.traj_colors,
                                        # Width of trajectories
                                        linewidths=self.traj_widths,
                                        # Set the order of artists;
                                        # trajectories should be at background
                                        zorder=1)
            # Add the collection of trajectories to the axis
            self.ax.add_collection(self.trajs)

    def __update_frame(self, frame: SystemOfBodies):
        """
        Updates frame in the animation.
        """
        # Generate data for plotting
        X, Y, trajectories = self.__generate_data(frame)
        # Change data (offsets) of the scatter plot (move to new positions)
        # (it takes "an array of tuples", shape (n, 2), hence the np.stack)
        self.bodies.set_offsets(np.stack((X, Y), axis=-1))
        # Move the labels to new positions
        self.__annotate_move(X, Y)
        # Change data to the LineCollection if they were to be plotted
        # (add new positions from history)
        if frame.no_hist is False:
            self.trajs.set_segments(trajectories)
        # Re-scale the limits to bigger if necessary
        xlim_min_got, xlim_max_got = self.ax.get_xlim()  # Get current limits
        ylim_min_got, ylim_max_got = self.ax.get_ylim()
        xlim_min, xlim_max, ylim_min, ylim_max = self.__determine_limits(X, Y)
        xlim_min_set, xlim_max_set = xlim_min_got, xlim_max_got  # To set
        ylim_min_set, ylim_max_set = ylim_min_got, ylim_max_got
        if xlim_min_got > xlim_min:  # Change only those which differ
            xlim_min_set = xlim_min
        if xlim_max_got < xlim_max:
            xlim_max_set = xlim_max
        if ylim_min_got > ylim_min:
            ylim_min_set = ylim_min
        if ylim_max_got < ylim_max:
            ylim_max_set = ylim_max
        if xlim_min_got > xlim_min or xlim_max_got < xlim_max:  # Re-scale
            self.ax.set_xlim(xlim_min_set, xlim_max_set)
        if ylim_min_got > ylim_min or ylim_max_got < ylim_max:
            self.ax.set_ylim(ylim_min_set, ylim_max_set)
        return self.bodies, self.trajs

    def __create_animation(self) -> None:
        """
        Creates the animation based on the settings given in the constructor.
        """
        # Set dark background if required
        if self.dark_bg is True:
            plt.style.use('dark_background')
        # Create a plot
        self.fig, self.ax = plt.subplots()
        # Set title
        self.fig.suptitle(self.title, fontsize=self.title_size)
        # Add units if not disabled
        if self.no_units is False:
            self.__init_units()
        # Hide axes if required
        if self.show_axes is False:
            self.ax.set_axis_off()
        # Add grid if required
        if self.show_grid is True:
            self.ax.grid(True, color=self.grid_color,
                         linewidth=0.5, linestyle='--')
        # Generate data for plotting
        X, Y, trajectories = self.__generate_data(self.system)
        # Set limits
        self.__init_limits(X, Y)
        # Create a scatter plot (bodies)
        self.__init_scatter(X, Y)
        # Add labels to bodies in the scatter plot
        self.__annotate_bodies(self.system)
        # Create trajectories as a LineCollection if they are to be plotted
        self.__init_trajectories(trajectories)
        # Create the animation
        self.anim = FuncAnimation(fig=self.fig,  # Figure to be animated
                                  # Functino to update the frame
                                  func=self.__update_frame,
                                  # Iterable object (system of bodies)
                                  # On iterating, it calculates the next state.
                                  # Stops iteration when limit is reached.
                                  # (see the respective iterator)
                                  frames=self.system,
                                  # Frame rate converted to a period in ms
                                  interval=1000 / self.frame_rate,
                                  # Do not redraw only differences
                                  # (cannot be set with annotations
                                  # and other complex artists!)
                                  blit=False,
                                  # Maximum number of frames that can be cached
                                  save_count=200)
        # Reset the style
        plt.style.use('default')

    def show(self) -> None:
        """
        Show animation based on the information from the constructor. \n
        *Note that after call of this function the animation is destroyed
        and then it is re-created anew!*
        """
        # Show animation if it has been chosen
        if self.no_show is True:
            raise RuntimeError("Requested operation cannot be performed "
                               "(showing animation disabled in ctor)!")
        # Check if animation has already been created (this should never occur)
        elif not hasattr(self, 'anim'):
            raise RuntimeError("Requested operation cannot be performed "
                               "(saving animation before its creation)!")
        else:
            # Display the animation (and it destroys it as well)
            plt.show()
            # Create the animation anew as it was destoryed by plt.show()
            self.__create_animation()

    def save(self,
             path: str,
             format: Literal['gif', 'mp4', 'avi'] = 'gif',
             dpi: float = 100,
             bitrate: int = -1) -> None:
        """
        Saves the animation. \n
        *Note that after call of this function the animation is exhausted
        and then it is re-created anew to recover a pure animation object!* \n
        Codec of the output video is selected according to the extension of
        the file by the writer.

        :param path: Path of the output video file (may be relative). \n
            Note that you must specify the right extension!
            (the ``path`` is treated as is; in fact, this determines format)
        :type path: str

        :param format: Format of the output video file. \n
            *Note that 'mp4' and 'avi' formats require ``ffmpeg`` to
            be installed in your system!*
        :type format: Literal['gif', 'mp4', 'avi']

        :param dpi: Dots per inch
        :type dpi: float

        :param bitrate: Bitrate (-1 means default value of writer)
        :type bitrate: int
        """
        # Check if it is required not to save
        if self.no_save is True:
            raise RuntimeError("Requested operation cannot be performed "
                               "(saving animation disabled in ctor)!")
        # Check if animation has already been created (this should never occur)
        elif not hasattr(self, 'anim'):
            raise RuntimeError("Requested operation cannot be performed "
                               "(saving animation before its creation)!")
        # Check proper argument ``format``
        elif format not in SUPPORTED_VIDEO_FMTS.keys():
            raise ValueError("Invalid format of the output video file!")
        # Save
        else:
            # Set metadata
            metadata = {
                'title': self.title,
                'comment':
                'Video generated by planetary2d'
            }
            # Save the video by 'ffmpeg' or by other default
            if SUPPORTED_VIDEO_FMTS[format] == 'ffmpeg':
                # Set the writer
                writer = FFMpegWriter(fps=self.frame_rate,
                                      bitrate=bitrate,
                                      metadata=metadata)
                # Save the file
                self.anim.save(path, writer=writer, dpi=dpi)
            else:
                # Save the file
                self.anim.save(path,
                               fps=self.frame_rate,
                               bitrate=bitrate,
                               dpi=dpi,
                               metadata=metadata)
            # Destroy figure
            plt.close(self.fig)
            # Create the animation anew as it was affected by save()
            # (it leaves the animation as if after iteration!)
            self.__create_animation()


def animate(necessary_data) -> None:
    """
    Convenience function for animating a system of bodies.
    """
    # TODO:
    # Create Animator object
    animator = Animator(necessary_data)
    # Animate
    animator.show()
    # Save animation if it has been set
    if 'save_animation' in necessary_data:
        animator.save_animation()
